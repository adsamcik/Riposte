package com.mememymood.feature.import_feature.data

import com.mememymood.core.model.MemeMetadata
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertTrue
import org.junit.Test

/**
 * Integration tests for CLI-generated JSON sidecar compatibility.
 *
 * These tests verify that the JSON sidecar files generated by the meme-my-mood-cli
 * Python tool can be correctly parsed by the Kotlin MemeMetadata class.
 *
 * Note: Tests for ZipImporter.extractBundle require Robolectric or Android
 * instrumentation tests due to Uri.fromFile() dependencies.
 */
class ZipImporterTest {

    private val json = Json { ignoreUnknownKeys = true }

    // ==================== CLI Output Compatibility Tests ====================

    @Test
    fun `parseMetadataJson handles minimal CLI output`() {
        // Minimal output from CLI: just emojis and required fields
        val cliOutput = """
            {
                "schemaVersion": "1.0",
                "emojis": ["ğŸ˜‚"],
                "createdAt": "2026-01-25T12:00:00+00:00",
                "appVersion": "cli-1.0.0"
            }
        """.trimIndent()

        val metadata = json.decodeFromString<MemeMetadata>(cliOutput)

        assertEquals("1.0", metadata.schemaVersion)
        assertEquals(listOf("ğŸ˜‚"), metadata.emojis)
        assertEquals("2026-01-25T12:00:00+00:00", metadata.createdAt)
        assertEquals("cli-1.0.0", metadata.appVersion)
    }

    @Test
    fun `parseMetadataJson handles full CLI output`() {
        // Full output from CLI with all fields populated
        val cliOutput = """
            {
                "schemaVersion": "1.0",
                "emojis": ["ğŸ‘¾", "ğŸ®", "ğŸ˜", "ğŸ•¹ï¸"],
                "createdAt": "2026-01-25T07:52:01.265630+00:00",
                "appVersion": "cli-1.0.0",
                "title": "Ultimate Gamer Vibes",
                "description": "A person in a gaming room wearing retro Space Invader-themed gear",
                "tags": ["gaming", "space invaders", "retro", "arcade", "funny"],
                "textContent": "Game Over"
            }
        """.trimIndent()

        val metadata = json.decodeFromString<MemeMetadata>(cliOutput)

        assertEquals("1.0", metadata.schemaVersion)
        assertEquals(listOf("ğŸ‘¾", "ğŸ®", "ğŸ˜", "ğŸ•¹ï¸"), metadata.emojis)
        assertEquals("Ultimate Gamer Vibes", metadata.title)
        assertEquals(
            "A person in a gaming room wearing retro Space Invader-themed gear",
            metadata.description,
        )
        assertEquals(listOf("gaming", "space invaders", "retro", "arcade", "funny"), metadata.tags)
        assertEquals("Game Over", metadata.textContent)
    }

    @Test
    fun `parseMetadataJson handles Unicode emojis`() {
        val cliOutput = """
            {
                "schemaVersion": "1.0",
                "emojis": ["ğŸ˜‚", "ğŸ”¥", "ğŸ‘¾", "â¤ï¸", "ğŸ³ï¸â€ğŸŒˆ", "ğŸ‘¨â€ğŸ’»"]
            }
        """.trimIndent()

        val metadata = json.decodeFromString<MemeMetadata>(cliOutput)

        assertEquals(6, metadata.emojis.size)
        assertTrue(metadata.emojis.contains("ğŸ˜‚"))
        assertTrue(metadata.emojis.contains("ğŸ”¥"))
        assertTrue(metadata.emojis.contains("ğŸ‘¾"))
        assertTrue(metadata.emojis.contains("â¤ï¸"))
        // ZWJ sequences
        assertTrue(metadata.emojis.contains("ğŸ³ï¸â€ğŸŒˆ"))
        assertTrue(metadata.emojis.contains("ğŸ‘¨â€ğŸ’»"))
    }

    @Test
    fun `parseMetadataJson handles Unicode text content`() {
        val cliOutput = """
            {
                "schemaVersion": "1.0",
                "emojis": ["ğŸ˜‚"],
                "title": "æ—¥æœ¬èªã‚¿ã‚¤ãƒˆãƒ«",
                "description": "ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ä¸­æ–‡æè¿°",
                "textContent": "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"
            }
        """.trimIndent()

        val metadata = json.decodeFromString<MemeMetadata>(cliOutput)

        assertEquals("æ—¥æœ¬èªã‚¿ã‚¤ãƒˆãƒ«", metadata.title)
        assertEquals("ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ä¸­æ–‡æè¿°", metadata.description)
        assertEquals("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", metadata.textContent)
    }

    @Test
    fun `parseMetadataJson ignores unknown fields`() {
        // CLI might add new fields in future versions
        val cliOutput = """
            {
                "schemaVersion": "1.0",
                "emojis": ["ğŸ˜‚"],
                "unknownField": "should be ignored",
                "anotherNewField": 123
            }
        """.trimIndent()

        val metadata = json.decodeFromString<MemeMetadata>(cliOutput)

        assertEquals("1.0", metadata.schemaVersion)
        assertEquals(listOf("ğŸ˜‚"), metadata.emojis)
    }

    @Test
    fun `parseMetadataJson handles empty tags list`() {
        val cliOutput = """
            {
                "schemaVersion": "1.0",
                "emojis": ["ğŸ˜‚"],
                "tags": []
            }
        """.trimIndent()

        val metadata = json.decodeFromString<MemeMetadata>(cliOutput)

        assertTrue(metadata.tags.isEmpty())
    }

    @Test
    fun `parseMetadataJson handles missing optional fields`() {
        val cliOutput = """
            {
                "schemaVersion": "1.0",
                "emojis": ["ğŸ˜‚"]
            }
        """.trimIndent()

        val metadata = json.decodeFromString<MemeMetadata>(cliOutput)

        assertEquals("1.0", metadata.schemaVersion)
        assertEquals(listOf("ğŸ˜‚"), metadata.emojis)
        assertEquals(null, metadata.title)
        assertEquals(null, metadata.description)
        assertEquals(null, metadata.textContent)
        assertEquals(null, metadata.createdAt)
        assertEquals(null, metadata.appVersion)
        assertTrue(metadata.tags.isEmpty())
    }

    @Test
    fun `metadata round trip serialization works`() {
        // Create metadata as CLI would
        val original = MemeMetadata(
            schemaVersion = "1.0",
            emojis = listOf("ğŸ˜‚", "ğŸ”¥", "ğŸ’¯"),
            title = "Test Meme",
            description = "A funny meme",
            createdAt = "2026-01-25T12:00:00+00:00",
            appVersion = "cli-1.0.0",
            tags = listOf("funny", "test"),
            textContent = "Hello World",
        )

        // Serialize as CLI does
        val jsonString = json.encodeToString(original)

        // Parse as Android app does
        val parsed = json.decodeFromString<MemeMetadata>(jsonString)

        assertEquals(original.schemaVersion, parsed.schemaVersion)
        assertEquals(original.emojis, parsed.emojis)
        assertEquals(original.title, parsed.title)
        assertEquals(original.description, parsed.description)
        assertEquals(original.createdAt, parsed.createdAt)
        assertEquals(original.appVersion, parsed.appVersion)
        assertEquals(original.tags, parsed.tags)
        assertEquals(original.textContent, parsed.textContent)
    }

    @Test
    fun `toEmojiTags converts emojis correctly`() {
        val metadata = MemeMetadata(emojis = listOf("ğŸ˜‚", "ğŸ”¥"))

        val emojiTags = metadata.toEmojiTags()

        assertEquals(2, emojiTags.size)
        assertEquals("ğŸ˜‚", emojiTags[0].emoji)
        assertEquals("ğŸ”¥", emojiTags[1].emoji)
    }

    // ==================== Sidecar Naming Convention Tests ====================

    @Test
    fun `sidecar file naming convention matches CLI output`() {
        // CLI creates sidecars as: image.jpg -> image.jpg.json
        // ZipImporter does: entryName.removeSuffix(".json") to get image name

        val testCases = listOf(
            "image.jpg.json" to "image.jpg",
            "meme.png.json" to "meme.png",
            "photo.webp.json" to "photo.webp",
            "funny meme.jpg.json" to "funny meme.jpg",
            "test.image.jpg.json" to "test.image.jpg",
        )

        for ((sidecarName, expectedImageName) in testCases) {
            val recoveredImageName = sidecarName.removeSuffix(".json")
            assertEquals(expectedImageName, recoveredImageName)
        }
    }
}
